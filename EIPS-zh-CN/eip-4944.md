---
eip: 4944
title: Contract with Exactly One Non-fungible Token
description: An ERC721-compatible single-token NFT
author: Víctor Muñoz (@victormunoz), Josep Lluis de la Rosa (@peplluis7), Andres El-Fakdi (@Bluezfish)
discussions-to: https://ethereum-magicians.org/t/erc721-minting-only-one-token/8602/2
status: 停滞
type: 标准跟踪
category: ERC
created: 2022-03-25
requires: 721
---

## 摘要
The following describes standard functions for an [ERC-721](./eip-721.md) compatible contract with a total supply of one. This allows an NFT to be associated uniquely with a single contract address. This allows an NFT to be associated uniquely with a single contract address.

## 动机
If the ERC721 was modified to mint only 1 token (per contract), then the contract address could be identified uniquely with that minted token (instead of the tuple contract address + token id, as ERC721 requires). This change would enable automatically all the capabilities of composable tokens ERC-998 (own other ERC721 or ERC20) natively without adding any extra code, just forbidding to mint more than one token per deployed contract. Then the NFT minted with this contract could operate with his "budget" (the ERC20 he owned) and also trade with the other NFTs he could own. Just like an autonomous agent, that could decide what to do with his properties (sell his NFTs, buy other NFTs, etc).

The first use case that is devised is for value preservation. The first use case that is devised is for value preservation. Digital assets, as NFTs, have value that has to be preserved in order to not be lost. If the asset has its own budget (in other ERC20 coins), could use it to autopreserve itself. If the asset has its own budget (in other ERC20 coins), could use it to autopreserve itself.

## 规范
The constructor should mint the unique token of the contract, and then the mint function should add a restriction to avoid further minting.

Also, a `tokenTransfer` function should be added in order to allow the contract owner to transact with the ERC20 tokens owned by the contract/NFT itself. So that if the contract receives a transfer of ERC20 tokens, the owner of the NFT could spend it from the contract wallet. So that if the contract receives a transfer of ERC20 tokens, the owner of the NFT could spend it from the contract wallet.

## 基本原理
The main motivation is to keep the contract compatible with current ERC721 platforms.

## Backwards Compatibility
There are no backwards compatibility issues.

## Reference Implementation
Add the variable `_minted` in the contract:

``` solidity
    bool private _minted;
```

In the constructor, automint the first token and set the variable to true:

``` solidity
    constructor(string memory name, string memory symbol, string memory base_uri) ERC721(name, symbol) {
        baseUri = base_uri;
        mint(msg.sender,0);
        _minted = true;
    }
```

Add additional functions to interact with the NFT properties (for instance, ERC20):

``` solidity
    modifier onlyOwner() {
        require(balanceOf(msg.sender) > 0, "Caller is not the owner of the NFT");
        _;
    }

    function transferTokens(IERC20 token, address recipient, uint256 amount) public onlyOwner {
        token.transfer(recipient, amount);
    }
```


## Security Considerations
No security issues found.

## 版权声明
Copyright and related rights waived via [CC0](../LICENSE.md).
